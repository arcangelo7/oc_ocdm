#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for any purpose
# with or without fee is hereby granted, provided that the above copyright notice
# and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
from __future__ import annotations

from datetime import datetime

from rdflib import URIRef, XSD

from typing import TYPE_CHECKING, List, Optional

if TYPE_CHECKING:
    from oc_graphlib.bibliographic_reference import BibliographicReference
    from oc_graphlib.discourse_element import DiscourseElement
    from oc_graphlib.resource_embodiment import ResourceEmbodiment
from oc_graphlib.graph_entity import GraphEntity
from oc_graphlib.bibliographic_entity import BibliographicEntity

"""
Notes about BR:

    HAS TYPE is generated by the factory methods!
    IS PART OF has inverted logic! Have a look below for more info.
    HAS PART (DiscourseElement) has both direct and inverted logic implemented! Have a look below for more info.
    HAS CONTRIBUTOR is generated by method AgentRole._associate_role_with_document! Have a look at
                    agent_role.py for more info.
    Chill down, everything seems OK here!
"""


class BibliographicResource(BibliographicEntity):
    # HAS TITLE
    # <self.res> DCTERMS:title "string"
    def create_title(self, string: str) -> bool:
        return self._create_literal(GraphEntity.title, string)

    # HAS SUBTITLE
    # <self.res> FABIO:hasSubtitle "string"
    def create_subtitle(self, string: str) -> bool:
        return self._create_literal(GraphEntity.has_subtitle, string)

    """
    AAA: this should have inverse logic!!!
    See below:

    # IS PART OF (BibliographicResource)
     def is_part_of(self, br_res):
        self.g.add((self.res, GraphEntity.part_of, URIRef(str(br_res))))
    """
    # IS PART OF (BibliographicResource)
    # <br_res> FRBR:partOf <self.res>
    def has_part(self, br_res: BibliographicResource) -> None:
        br_res.g.add((URIRef(str(br_res)), GraphEntity.part_of, self.res))

    # CITES (BibliographicResource)
    # <self.res> CITO:cites <br_res>
    def has_citation(self, br_res: BibliographicResource) -> None:
        self.g.add((self.res, GraphEntity.cites, URIRef(str(br_res))))

    # HAS PUBLICATION DATE
    # <self.res> PRISM:publicationDate "string"
    def create_pub_date(self, date_list: List[Optional[int]] = None) -> bool:
        if date_list is not None:
            l_date_list = len(date_list)
            if l_date_list != 0 and date_list[0] is not None:
                if l_date_list == 3 and \
                        ((date_list[1] is not None and date_list[1] != 1) or
                         (date_list[2] is not None and date_list[2] != 1)):
                    cur_type = XSD.date
                    string = datetime(
                        date_list[0], date_list[1], date_list[2], 0, 0).strftime('%Y-%m-%d')
                elif l_date_list == 2 and date_list[1] is not None:
                    cur_type = XSD.gYearMonth
                    string = datetime(
                        date_list[0], date_list[1], 1, 0, 0).strftime('%Y-%m')
                else:
                    cur_type = XSD.gYear
                    string = datetime(date_list[0], 1, 1, 0, 0).strftime('%Y')
                return self._create_literal(GraphEntity.has_publication_date, string, cur_type, False)
        return False # Added by @iosonopersia

    # IS EMBODIED AS (ResourceEmbodiment)
    # <self.res> FRBR:embodiment <re_res>
    def has_format(self, re_res: ResourceEmbodiment) -> None:
        self.g.add((self.res, GraphEntity.embodiment, URIRef(str(re_res))))

    # HAS NUMBER
    # <self.res> FABIO:hasSequenceIdentifier "string"
    def create_number(self, string: str) -> bool:
        return self._create_literal(GraphEntity.has_sequence_identifier, string)

    # HAS EDITION
    # <self.res> PRISM:edition "string"
    def has_edition(self, string: str) -> bool:
        return self._create_literal(GraphEntity.has_edition, string)

    # HAS PART (BibliographicReference)
    # <self.res> FRBR:part <be_res>
    def contains_in_reference_list(self, be_res: BibliographicReference) -> None:
        self.g.add((self.res, GraphEntity.contains_reference, URIRef(str(be_res))))

    # HAS PART (DiscourseElement)
    # <self.res> FRBR:part <de_res>
    def contains_discourse_element(self, de_res: DiscourseElement) -> None:  #  new
        self.g.add((self.res, GraphEntity.contains_de, URIRef(str(de_res))))

    """
        HAS PART (DiscourseElement) with inverted logic (IS PART OF)
    """

    # <de_res> FRBR:part <self.res>
    def contained_in_discourse_element(self, de_res: DiscourseElement) -> None:  #  new
        self.g.add((URIRef(str(de_res)), GraphEntity.contains_de, self.res))

    """
    AAA: this should have inverse logic and it should belong to BibliographicReference class!!!
    See below:

    class BibliographicReference:
        # REFERENCES (BibliographicResource)
        def has_reference(self, br_res: BibliographicResource):
            self.g.add((self.res, GraphEntity.references, URIRef(str(br_res))))
    """
    # <be_res> BIRO:references <self.res>
    def has_reference(self, be_res: BibliographicReference) -> None:
        be_res.g.add((URIRef(str(be_res)), GraphEntity.references, self.res))

    # HAS RELATED DOCUMENT
    # <self.res> DCTERMS:relation <thing_ref>
    def has_related_document(self, thing_ref: URIRef) -> None:
        self.g.add((self.res, GraphEntity.relation, thing_ref))

    # ++++++++++++++++++++++++ FACTORY METHODS ++++++++++++++++++++++++
    # <self.res> RDF:type <type>

    def create_archival_document(self) -> None:  # new
        self._create_type(GraphEntity.archival_document)

    def create_book(self) -> None:
        self._create_type(GraphEntity.book)

    def create_book_chapter(self) -> None:
        self._create_type(GraphEntity.book_chapter)

    def create_book_part(self) -> None:
        self._create_type(GraphEntity.part)

    def create_book_section(self) -> None:
        self._create_type(GraphEntity.expression_collection)

    def create_book_series(self) -> None:
        self._create_type(GraphEntity.book_series)

    def create_book_set(self) -> None:
        self._create_type(GraphEntity.book_set)

    def create_book_track(self) -> None:
        self._create_type(GraphEntity.expression)

    def create_component(self) -> None:
        self._create_type(GraphEntity.expression)

    def create_dataset(self) -> None:
        self._create_type(GraphEntity.data_file)

    def create_dissertation(self) -> None:
        self._create_type(GraphEntity.thesis)

    def create_edited_book(self) -> None:
        self._create_type(GraphEntity.book)

    def create_journal_article(self) -> None:
        self._create_type(GraphEntity.journal_article)

    def create_issue(self) -> None:
        self._create_type(GraphEntity.journal_issue)

    def create_volume(self) -> None:
        self._create_type(GraphEntity.journal_volume)

    def create_journal(self) -> None:
        self._create_type(GraphEntity.journal)

    def create_monograph(self) -> None:
        self._create_type(GraphEntity.book)

    def create_proceedings_article(self) -> None:
        self._create_type(GraphEntity.proceedings_paper)

    def create_proceedings(self) -> None:
        self._create_type(GraphEntity.academic_proceedings)

    def create_reference_book(self) -> None:
        self._create_type(GraphEntity.reference_book)

    def create_reference_entry(self) -> None:
        self._create_type(GraphEntity.reference_entry)

    def create_report_series(self) -> None:
        self._create_type(GraphEntity.series)

    def create_report(self) -> None:
        self._create_type(GraphEntity.report_document)

    def create_standard_series(self) -> None:
        self._create_type(GraphEntity.series)

    def create_standard(self) -> None:
        self._create_type(GraphEntity.specification_document)

    def create_series(self) -> None:
        self._create_type(GraphEntity.series)  # new

    def create_expression_collection(self) -> None:
        self._create_type(GraphEntity.expression_collection)

    def create_other(self) -> None:
        self._create_type(GraphEntity.expression)
