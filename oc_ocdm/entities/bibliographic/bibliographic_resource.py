#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2016, Silvio Peroni <essepuntato@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for any purpose
# with or without fee is hereby granted, provided that the above copyright notice
# and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,
# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
from __future__ import annotations

from typing import TYPE_CHECKING, List, Optional

from rdflib import URIRef, RDF

from oc_ocdm.support import create_date

if TYPE_CHECKING:
    from oc_ocdm.entities.bibliographic import BibliographicReference
    from oc_ocdm.entities.bibliographic import DiscourseElement
    from oc_ocdm.entities.bibliographic import ResourceEmbodiment
from oc_ocdm import GraphEntity
from oc_ocdm.entities import BibliographicEntity

"""
Notes about BR:

    HAS TYPE is generated by the factory methods!
    IS PART OF has inverted logic! Have a look below for more info.
    HAS PART (DiscourseElement) has both direct and inverted logic implemented! Have a look below for more info.
    HAS CONTRIBUTOR is generated by method AgentRole._associate_role_with_document! Have a look at
                    agent_role.py for more info.
    Chill down, everything seems OK here!
"""


class BibliographicResource(BibliographicEntity):
    """Bibliographic resource (short: br): a published bibliographic resource that cites/is
       cited by another published bibliographic resource."""

    # HAS TITLE
    # <self.res> DCTERMS:title "string"
    def create_title(self, string: str) -> bool:
        """The title of the bibliographic resource.
        """
        self.remove_title()
        return self._create_literal(GraphEntity.title, string)

    def remove_title(self) -> None:
        self.g.remove((self.res, GraphEntity.title, None))

    # HAS SUBTITLE
    # <self.res> FABIO:hasSubtitle "string"
    def create_subtitle(self, string: str) -> bool:
        """The subtitle of the bibliographic resource.
        """
        self.remove_subtitle()
        return self._create_literal(GraphEntity.has_subtitle, string)

    def remove_subtitle(self) -> None:
        self.g.remove((self.res, GraphEntity.has_subtitle, None))

    """
    AAA: this should have inverse logic!!!
    See below:

    # IS PART OF (BibliographicResource)
     def is_part_of(self, br_res):
        self.g.add((self.res, GraphEntity.part_of, URIRef(str(br_res))))
    """
    # IS PART OF (BibliographicResource)
    # <br_res> FRBR:partOf <self.res>
    def has_part(self, br_res: BibliographicResource) -> None:
        """The corpus identifier of the bibliographic resource (e.g. issue, volume, journal,
        conference proceedings) that contains the subject bibliographic resource.
        """
        br_res.g.add((URIRef(str(br_res)), GraphEntity.part_of, self.res))

    def remove_part(self, br_res: BibliographicResource = None) -> None:
        if br_res is not None:
            if (br_res.res, GraphEntity.part_of, self.res) in br_res.g:
                br_res.g.remove((br_res.res, GraphEntity.part_of, None))
        else:
            if self.g_set is not None:
                for br_res in self.g_set.get_br():
                    if (br_res.res, GraphEntity.part_of, self.res) in br_res.g:
                        br_res.g.remove((br_res.res, GraphEntity.part_of, None))

    # CITES (BibliographicResource)
    # <self.res> CITO:cites <br_res>
    def has_citation(self, br_res: BibliographicResource) -> None:
        """The corpus identifier of the bibliographic resource cited by the subject bibliographic
        resource.
        """
        self.g.add((self.res, GraphEntity.cites, URIRef(str(br_res))))

    def remove_citation(self, br_res: BibliographicResource = None) -> None:
        if br_res is not None:
            self.g.remove((self.res, GraphEntity.cites, br_res.res))
        else:
            self.g.remove((self.res, GraphEntity.cites, None))

    # HAS PUBLICATION DATE
    # <self.res> PRISM:publicationDate "string"
    def create_pub_date(self, date_list: List[Optional[int]] = None) -> bool:
        """The date of publication of the bibliographic resource.
        """
        cur_type, string = create_date(date_list)
        if cur_type is not None and string is not None:
            self.remove_pub_date()
            return self._create_literal(GraphEntity.has_publication_date, string, cur_type, False)
        return False  # Added by @iosonopersia

    def remove_pub_date(self) -> None:
        self.g.remove((self.res, GraphEntity.has_publication_date, None))

    # IS EMBODIED AS (ResourceEmbodiment)
    # <self.res> FRBR:embodiment <re_res>
    def has_format(self, re_res: ResourceEmbodiment) -> None:
        """The corpus identifier of the resource embodiment defining the format in which the
        bibliographic resource has been embodied, which can be either print or digital.
        """
        self.g.add((self.res, GraphEntity.embodiment, URIRef(str(re_res))))

    def remove_format(self, re_res: ResourceEmbodiment = None):
        if re_res is not None:
            self.g.remove((self.res, GraphEntity.embodiment, re_res.res))
        else:
            self.g.remove((self.res, GraphEntity.embodiment, None))

    # HAS NUMBER
    # <self.res> FABIO:hasSequenceIdentifier "string"
    def create_number(self, string: str) -> bool:
        """A literal (for example a number or a letter) that identifies the sequence position of the
        bibliographic resource as a particular item within a larger collection (e.g. an article
        number within a journal issue, a volume number of a journal, a chapter number within
        a book).
        """
        self.remove_number()
        return self._create_literal(GraphEntity.has_sequence_identifier, string)

    def remove_number(self) -> None:
        self.g.remove((self.res, GraphEntity.has_sequence_identifier, None))

    # HAS EDITION
    # <self.res> PRISM:edition "string"
    def has_edition(self, string: str) -> bool:
        """An identifier for one of several alternative editions of a particular bibliographic
        resource.
        """
        self.remove_edition()
        return self._create_literal(GraphEntity.has_edition, string)

    def remove_edition(self) -> None:
        self.g.remove((self.res, GraphEntity.has_edition, None))

    # HAS PART (BibliographicReference)
    # <self.res> FRBR:part <be_res>
    def contains_in_reference_list(self, be_res: BibliographicReference) -> None:
        """A bibliographic reference within the bibliographic resource, or a discourse element
        wherein the text of the bibliographic resources can be organized.
        """
        self.g.add((self.res, GraphEntity.contains_reference, URIRef(str(be_res))))

    def remove_in_reference_list(self, be_res: BibliographicReference = None) -> None:
        if be_res is not None:
            self.g.remove((self.res, GraphEntity.contains_reference, be_res.res))
        else:
            self.g.remove((self.res, GraphEntity.contains_reference, None))

    # HAS PART (DiscourseElement)
    # <self.res> FRBR:part <de_res>
    def contains_discourse_element(self, de_res: DiscourseElement) -> None:
        """A bibliographic reference within the bibliographic resource, or a discourse element
        wherein the text of the bibliographic resources can be organized.
        """
        self.g.add((self.res, GraphEntity.contains_de, URIRef(str(de_res))))

    def remove_discourse_element(self, de_res: DiscourseElement = None) -> None:
        if de_res is not None:
            self.g.remove((self.res, GraphEntity.contains_de, de_res.res))
        else:
            self.g.remove((self.res, GraphEntity.contains_de, None))

    """
        HAS PART (DiscourseElement) with inverted logic (IS PART OF)
    """

    # <de_res> FRBR:part <self.res>
    def contained_in_discourse_element(self, de_res: DiscourseElement) -> None:
        """A bibliographic reference within the bibliographic resource, or a discourse element
        wherein the text of the bibliographic resources can be organized.
        """
        self.g.add((URIRef(str(de_res)), GraphEntity.contains_de, self.res))

    """
    AAA: this should have inverse logic and it should belong to BibliographicReference class!!!
    See below:

    class BibliographicReference:
        # REFERENCES (BibliographicResource)
        def has_reference(self, br_res: BibliographicResource):
            self.g.add((self.res, GraphEntity.references, URIRef(str(br_res))))
    """
    # <be_res> BIRO:references <self.res>
    def has_reference(self, be_res: BibliographicReference) -> None:
        """The bibliographic reference that cites this bibliographic resource.
        """
        be_res.g.add((URIRef(str(be_res)), GraphEntity.references, self.res))

    def remove_reference(self, be_res: BibliographicReference = None) -> None:
        if be_res is not None:
            if (be_res.res, GraphEntity.references, self.res) in be_res.g:
                be_res.g.remove((be_res.res, GraphEntity.references, None))
        else:
            if self.g_set is not None:
                for be_res in self.g_set.get_be():
                    if (be_res.res, GraphEntity.references, self.res) in be_res.g:
                        be_res.g.remove((be_res.res, GraphEntity.references, None))

    # HAS RELATED DOCUMENT
    # <self.res> DCTERMS:relation <thing_ref>
    def has_related_document(self, thing_ref: URIRef) -> None:
        """A document external to the Corpus, that is related to the bibliographic resource (such
        as a version of the bibliographic resource – for example a preprint – recorded in an
        external database).
        """
        self.g.add((self.res, GraphEntity.relation, thing_ref))

    def remove_related_document(self, thing_ref: URIRef = None) -> None:
        if thing_ref is not None:
            self.g.remove((self.res, GraphEntity.relation, thing_ref))
        else:
            self.g.remove((self.res, GraphEntity.relation, None))

    # ++++++++++++++++++++++++ FACTORY METHODS ++++++++++++++++++++++++
    # <self.res> RDF:type <type>

    def create_archival_document(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.archival_document)

    def create_book(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.book)

    def create_book_chapter(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.book_chapter)

    def create_book_part(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.part)

    def create_book_section(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.expression_collection)

    def create_book_series(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.book_series)

    def create_book_set(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.book_set)

    def create_book_track(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.expression)

    def create_component(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.expression)

    def create_dataset(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.data_file)

    def create_dissertation(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.thesis)

    def create_edited_book(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.book)

    def create_journal_article(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.journal_article)

    def create_issue(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.journal_issue)

    def create_volume(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.journal_volume)

    def create_journal(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.journal)

    def create_monograph(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.book)

    def create_proceedings_article(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.proceedings_paper)

    def create_proceedings(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.academic_proceedings)

    def create_reference_book(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.reference_book)

    def create_reference_entry(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.reference_entry)

    def create_report_series(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.series)

    def create_report(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.report_document)

    def create_standard_series(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.series)

    def create_standard(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.specification_document)

    def create_series(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.series)

    def create_expression_collection(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.expression_collection)

    def create_other(self) -> None:
        """The type of the bibliographic resource
        """
        self._create_type(GraphEntity.expression)

    def remove_type(self, type_ref: URIRef = None) -> None:
        if type_ref is not None:
            self.g.remove((self.res, RDF.type, type_ref))
        else:
            self.g.remove((self.res, RDF.type, None))
